# -*- coding: utf-8 -*-
"""CreditCradFraudDetection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12Tg6cEEJC6vQ_Y0PNvwYqokflSUbfPx0
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler

creditcard = pd.read_csv('/content/creditcard.csv')

creditcard.head()

pd.options.display.max_columns = None

creditcard.head()

creditcard.tail()

creditcard.shape

print("Number of columns: {}", format(creditcard.shape[1]))
print("Number of rows:{}", format(creditcard.shape[0]))

creditcard.info()

creditcard.isnull().sum()

sc = StandardScaler()
creditcard['Amount'] = sc.fit_transform(pd.DataFrame(creditcard['Amount']))

creditcard.head()

creditcard.drop(['Time'], axis = 1)

creditcard.duplicated().any()

creditcard.shape

creditcard['Class'].value_counts()

import seaborn as sns
import matplotlib.pyplot as plt
plt.style.use('ggplot')

sns.countplot(creditcard['Class'])
plt.show()

import pandas as pd # Import pandas to handle dataframes
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score
# Assuming 'creditcard' is a pandas DataFrame, handle missing values
creditcard = creditcard.dropna()  # Drop rows with missing values

# Proceed with the rest of your code
x = creditcard.drop('Class', axis=1)
y = creditcard['Class']

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

classifier = {
    "Logistic Regression": LogisticRegression(),  # Fix typo in key
    "Decision Tree Classifier": DecisionTreeClassifier(),
}

for name, clf in classifier.items():
    print(f"\n============{name}===========")
    clf.fit(x_train, y_train)
    y_pred = clf.predict(x_test)
    print(f"\n Accuracy: {accuracy_score(y_test, y_pred)}")
    print(f"\n Precision: {precision_score(y_test, y_pred)}")
    print(f"\n Recall: {recall_score(y_test, y_pred)}")
    print(f"\n F1 Score: {f1_score(y_test, y_pred)}") # Use f1_score for F1 Score

#undersampling

normal = creditcard[creditcard['Class']==0]
fraud = creditcard[creditcard['Class']==1]

normal.shape

fraud.shape

normal_sample = normal.sample(n = 3)

normal_sample.shape

new_creditcard = pd.concat([normal_sample, fraud], ignore_index= True)

new_creditcard.head()

new_creditcard['Class'].value_counts()

x = new_creditcard.drop('Class', axis=1)
y = new_creditcard['Class']

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

classifier = {
    "Logistic Regression": LogisticRegression(),  # Fix typo in key
    "Decision Tree Classifier": DecisionTreeClassifier(),
}

for name, clf in classifier.items():
    print(f"\n============{name}===========")
    clf.fit(x_train, y_train)
    y_pred = clf.predict(x_test)
    print(f"\n Accuracy: {accuracy_score(y_test, y_pred)}")
    print(f"\n Precision: {precision_score(y_test, y_pred)}")
    print(f"\n Recall: {recall_score(y_test, y_pred)}")
    print(f"\n F1 Score: {f1_score(y_test, y_pred)}") # Use f1_score for F1 Score

#sampling

x = creditcard.drop('Class', axis=1)
y = creditcard['Class']

x.shape

y.shape

from imblearn.over_sampling import SMOTE

# Instantiate SMOTE with a smaller k_neighbors value
smote = SMOTE(k_neighbors=2)  # Adjust 2 to a value less than or equal to the number of minority class samples

x_res, y_res = smote.fit_resample(x, y)

y_res.value_counts()

x_train, x_test, y_train, y_test = train_test_split(x_res, y_res, test_size=0.2, random_state=42)

classifier = {
    "Logistic Regression": LogisticRegression(),  # Fix typo in key
    "Decision Tree Classifier": DecisionTreeClassifier(),
}

for name, clf in classifier.items():
    print(f"\n============{name}===========")
    clf.fit(x_train, y_train)
    y_pred = clf.predict(x_test)
    print(f"\n Accuracy: {accuracy_score(y_test, y_pred)}")
    print(f"\n Precision: {precision_score(y_test, y_pred)}")
    print(f"\n Recall: {recall_score(y_test, y_pred)}")
    print(f"\n F1 Score: {f1_score(y_test, y_pred)}") # Use f1_score for F1 Score

DecisionTreeClassifier()
dtc.fit(x_res,y_res)

import joblib

joblib.dump(dtc, "credit_card_model.pkl")

model = joblib.load( "credit_card_model.pkl")

pred = model.predict([[-1.340163075,	1.773209343,	0.379779593,	-0.503198133,	1.800499381,	0.791460956,
-0.185226008,	1.79299334,	-0.863291275,	-0.01030888, 1.247203168,	0.23760894,
0.877736755,	1.548717847,	0.403033934,	-0.407193377,	0.095921462,	0.592940745,
0.462388, 0.098698, 0.363787, 0.090794, 1.378155, 0.266151, 0.37979, 1.800499, 0.237609, 0.615375, 1.249376, -0.09925                  ]])

pred[0]

if pred[0] == 0:
  print("Normal Transaction")
else:
  print("Fraud Transcation")  